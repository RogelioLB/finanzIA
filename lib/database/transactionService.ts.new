import { v4 as uuidv4 } from "uuid";
import { SQLiteRunResult } from "expo-sqlite";
import { openDatabase } from "./database";
import { DatabaseResult, Transaction, TransactionType } from "../models/types";
import { updateAccountBalance } from "./accountService";

/**
 * Crea una nueva transacción y actualiza el saldo de la(s) cuenta(s) involucrada(s)
 * 
 * @param transaction Datos de la transacción a crear
 * @returns Promise con el resultado de la operación
 */
export async function createTransaction(
  transaction: Omit<Transaction, 'id' | 'created_at' | 'updated_at' | 'is_deleted' | 'sync_status' | 'last_synced_at'>
): Promise<DatabaseResult<Transaction>> {
  const db = openDatabase();
  const id = uuidv4();
  const now = Date.now();

  // Validamos los datos de la transacción según su tipo
  if (!transaction.type) {
    return { success: false, error: "El tipo de transacción es requerido" };
  }

  if (!transaction.account_id) {
    return { success: false, error: "La cuenta origen es requerida" };
  }

  if (transaction.type === "transfer" && !transaction.to_account_id) {
    return { success: false, error: "La cuenta destino es requerida para transferencias" };
  }

  if (transaction.amount <= 0) {
    return { success: false, error: "El monto debe ser mayor que cero" };
  }

  return new Promise((resolve) => {
    db.withTransactionAsync(async () => {
      try {
        // Insertamos la transacción
        const result = await db.runAsync(
          `INSERT INTO transactions (
            id, account_id, to_account_id, category_id, 
            type, amount, description, date,
            created_at, updated_at, sync_status
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            id,
            transaction.account_id,
            transaction.to_account_id ?? null,
            transaction.category_id ?? null,
            transaction.type,
            transaction.amount,
            transaction.description ?? null,
            transaction.date ?? now,
            now,
            now,
            'local'
          ]
        ) as SQLiteRunResult & { rowsAffected: number };

        if (result.rowsAffected > 0) {
          // Actualizamos los saldos de las cuentas según el tipo de transacción
          switch (transaction.type) {
            case 'income':
              // Para ingresos, aumentamos el saldo de la cuenta
              await updateAccountBalance(transaction.account_id, transaction.amount);
              break;
            case 'expense':
              // Para gastos, disminuimos el saldo de la cuenta
              await updateAccountBalance(transaction.account_id, -transaction.amount);
              break;
            case 'transfer':
              // Para transferencias, disminuimos el saldo de la cuenta origen
              // y aumentamos el saldo de la cuenta destino
              await updateAccountBalance(transaction.account_id, -transaction.amount);
              if (transaction.to_account_id) {
                await updateAccountBalance(transaction.to_account_id, transaction.amount);
              }
              break;
          }

          // Creamos el objeto de respuesta
          const newTransaction: Transaction = {
            id,
            account_id: transaction.account_id,
            to_account_id: transaction.to_account_id ?? null,
            category_id: transaction.category_id ?? null,
            type: transaction.type,
            amount: transaction.amount,
            description: transaction.description ?? null,
            date: transaction.date ?? now,
            created_at: now,
            updated_at: now,
            is_deleted: 0,
            sync_status: 'local',
            last_synced_at: null
          };

          resolve({ success: true, data: newTransaction });
        } else {
          resolve({ success: false, error: "Error al crear la transacción" });
        }
      } catch (error) {
        resolve({ success: false, error: (error as Error).message });
      }
    });
  });
}

/**
 * Obtiene todas las transacciones no eliminadas con opciones de filtrado
 * 
 * @param filters Filtros opcionales para las transacciones
 * @returns Promise con el resultado de la operación
 */
export async function getTransactions(filters?: {
  accountId?: string;
  categoryId?: string;
  type?: TransactionType;
  startDate?: number;
  endDate?: number;
  limit?: number;
  offset?: number;
}): Promise<DatabaseResult<Transaction[]>> {
  const db = openDatabase();
  
  let query = `
    SELECT * FROM transactions 
    WHERE is_deleted = 0
  `;
  
  const queryParams: any[] = [];
  
  // Aplicamos los filtros si están presentes
  if (filters?.accountId) {
    query += ` AND account_id = ?`;
    queryParams.push(filters.accountId);
  }
  
  if (filters?.categoryId) {
    query += ` AND category_id = ?`;
    queryParams.push(filters.categoryId);
  }
  
  if (filters?.type) {
    query += ` AND type = ?`;
    queryParams.push(filters.type);
  }
  
  if (filters?.startDate) {
    query += ` AND date >= ?`;
    queryParams.push(filters.startDate);
  }
  
  if (filters?.endDate) {
    query += ` AND date <= ?`;
    queryParams.push(filters.endDate);
  }
  
  // Ordenamos por fecha descendente
  query += ` ORDER BY date DESC`;
  
  // Aplicamos límite y offset si están presentes
  if (filters?.limit) {
    query += ` LIMIT ?`;
    queryParams.push(filters.limit);
    
    if (filters?.offset) {
      query += ` OFFSET ?`;
      queryParams.push(filters.offset);
    }
  }
  
  return new Promise((resolve) => {
    db.withTransactionAsync(async () => {
      try {
        const transactions = await db.getAllAsync<Transaction>(query, queryParams);
        resolve({ success: true, data: transactions });
      } catch (error) {
        resolve({ success: false, error: (error as Error).message });
      }
    });
  });
}

/**
 * Obtiene una transacción por su ID
 * 
 * @param id ID de la transacción
 * @returns Promise con el resultado de la operación
 */
export async function getTransactionById(id: string): Promise<DatabaseResult<Transaction>> {
  const db = openDatabase();
  
  return new Promise((resolve) => {
    db.withTransactionAsync(async () => {
      try {
        const transaction = await db.getFirstAsync<Transaction>(
          `SELECT * FROM transactions WHERE id = ? AND is_deleted = 0`,
          [id]
        );
        
        if (transaction) {
          resolve({ success: true, data: transaction });
        } else {
          resolve({ success: false, error: "Transacción no encontrada" });
        }
      } catch (error) {
        resolve({ success: false, error: (error as Error).message });
      }
    });
  });
}

/**
 * Actualiza una transacción existente
 * 
 * @param id ID de la transacción a actualizar
 * @param transactionData Datos de la transacción a actualizar
 * @returns Promise con el resultado de la operación
 */
export async function updateTransaction(
  id: string, 
  transactionData: Partial<Transaction>
): Promise<DatabaseResult<Transaction>> {
  const db = openDatabase();
  const now = Date.now();
  
  // Obtenemos la transacción actual para poder calcular los cambios en los saldos
  const currentTransactionResult = await getTransactionById(id);
  if (!currentTransactionResult.success) {
    return currentTransactionResult;
  }
  
  const currentTransaction = currentTransactionResult.data;
  
  // Excluimos campos que no deben actualizarse directamente
  const { 
    id: _id, 
    created_at: _created_at, 
    updated_at: _updated_at, 
    is_deleted: _is_deleted,
    sync_status: _sync_status,
    last_synced_at: _last_synced_at,
    ...updateData 
  } = transactionData;

  // Construimos la consulta SQL de actualización
  let updateQuery = `UPDATE transactions SET updated_at = ?, sync_status = 'local'`;
  const queryParams: any[] = [now];
  
  // Agregamos cada campo a actualizar a la consulta
  Object.entries(updateData).forEach(([key, value]) => {
    if (value !== undefined) {
      updateQuery += `, ${key} = ?`;
      queryParams.push(value);
    }
  });
  
  updateQuery += ` WHERE id = ? AND is_deleted = 0`;
  queryParams.push(id);
  
  return new Promise((resolve) => {
    db.withTransactionAsync(async () => {
      try {
        // Primero revertimos los efectos de la transacción actual
        if (currentTransaction) {
          switch (currentTransaction.type) {
            case 'income':
              await updateAccountBalance(currentTransaction.account_id, -currentTransaction.amount);
              break;
            case 'expense':
              await updateAccountBalance(currentTransaction.account_id, currentTransaction.amount);
              break;
            case 'transfer':
              await updateAccountBalance(currentTransaction.account_id, currentTransaction.amount);
              if (currentTransaction.to_account_id) {
                await updateAccountBalance(currentTransaction.to_account_id, -currentTransaction.amount);
              }
              break;
          }
        }
        
        // Actualizamos la transacción en la base de datos
        const result = await db.runAsync(updateQuery, queryParams) as SQLiteRunResult & { rowsAffected: number };
        
        if (result.rowsAffected > 0) {
          // Obtenemos la transacción actualizada
          const updatedTransactionResult = await getTransactionById(id);
          
          if (updatedTransactionResult.success && updatedTransactionResult.data) {
            const updatedTransaction = updatedTransactionResult.data;
            
            // Aplicamos los efectos de la transacción actualizada
            switch (updatedTransaction.type) {
              case 'income':
                await updateAccountBalance(updatedTransaction.account_id, updatedTransaction.amount);
                break;
              case 'expense':
                await updateAccountBalance(updatedTransaction.account_id, -updatedTransaction.amount);
                break;
              case 'transfer':
                await updateAccountBalance(updatedTransaction.account_id, -updatedTransaction.amount);
                if (updatedTransaction.to_account_id) {
                  await updateAccountBalance(updatedTransaction.to_account_id, updatedTransaction.amount);
                }
                break;
            }
            
            resolve({ success: true, data: updatedTransaction });
          } else {
            resolve(updatedTransactionResult);
          }
        } else {
          resolve({ success: false, error: "No se pudo actualizar la transacción" });
        }
      } catch (error) {
        resolve({ success: false, error: (error as Error).message });
      }
    });
  });
}

/**
 * Elimina una transacción (marcado lógico) y ajusta los saldos de las cuentas
 * 
 * @param id ID de la transacción
 * @returns Promise con el resultado de la operación
 */
export async function deleteTransaction(id: string): Promise<DatabaseResult<boolean>> {
  const db = openDatabase();
  const now = Date.now();
  
  // Obtenemos la transacción para revertir sus efectos en los saldos
  const transactionResult = await getTransactionById(id);
  if (!transactionResult.success) {
    return { success: false, error: transactionResult.error };
  }
  
  const transaction = transactionResult.data;
  
  return new Promise((resolve) => {
    db.withTransactionAsync(async () => {
      try {
        // Primero revertimos los efectos de la transacción en los saldos
        if (transaction) {
          switch (transaction.type) {
            case 'income':
              await updateAccountBalance(transaction.account_id, -transaction.amount);
              break;
            case 'expense':
              await updateAccountBalance(transaction.account_id, transaction.amount);
              break;
            case 'transfer':
              await updateAccountBalance(transaction.account_id, transaction.amount);
              if (transaction.to_account_id) {
                await updateAccountBalance(transaction.to_account_id, -transaction.amount);
              }
              break;
          }
        }
        
        // Marcamos la transacción como eliminada (soft delete)
        const result = await db.runAsync(
          `UPDATE transactions SET is_deleted = 1, updated_at = ?, sync_status = 'local' WHERE id = ?`,
          [now, id]
        ) as SQLiteRunResult & { rowsAffected: number };
        
        if (result.rowsAffected > 0) {
          resolve({ success: true, data: true });
        } else {
          resolve({ success: false, error: "No se pudo eliminar la transacción" });
        }
      } catch (error) {
        resolve({ success: false, error: (error as Error).message });
      }
    });
  });
}

/**
 * Obtiene un resumen de transacciones por categoría en un período de tiempo
 * 
 * @param filters Filtros para el resumen (fechas, tipo de transacción)
 * @returns Promise con el resultado de la operación
 */
export async function getTransactionSummaryByCategory(filters: {
  startDate?: number;
  endDate?: number;
  type?: TransactionType;
  accountId?: string;
}): Promise<DatabaseResult<{categoryId: string | null, total: number}[]>> {
  const db = openDatabase();
  
  let query = `
    SELECT 
      category_id as categoryId, 
      SUM(amount) as total 
    FROM transactions 
    WHERE is_deleted = 0
  `;
  
  const queryParams: any[] = [];
  
  // Aplicamos los filtros si están presentes
  if (filters.type) {
    query += ` AND type = ?`;
    queryParams.push(filters.type);
  }
  
  if (filters.accountId) {
    query += ` AND account_id = ?`;
    queryParams.push(filters.accountId);
  }
  
  if (filters.startDate) {
    query += ` AND date >= ?`;
    queryParams.push(filters.startDate);
  }
  
  if (filters.endDate) {
    query += ` AND date <= ?`;
    queryParams.push(filters.endDate);
  }
  
  // Agrupamos por categoría
  query += ` GROUP BY category_id ORDER BY total DESC`;
  
  return new Promise((resolve) => {
    db.withTransactionAsync(async () => {
      try {
        const summary = await db.getAllAsync<{categoryId: string | null, total: number}>(query, queryParams);
        resolve({ success: true, data: summary });
      } catch (error) {
        resolve({ success: false, error: (error as Error).message });
      }
    });
  });
}

/**
 * Obtiene el flujo de dinero (ingresos y gastos) por día, semana o mes
 * 
 * @param groupBy Agrupación temporal ('day', 'week', 'month')
 * @param filters Filtros adicionales
 * @returns Promise con el resultado de la operación
 */
export async function getCashFlow(
  groupBy: 'day' | 'week' | 'month' = 'month',
  filters?: {
    startDate?: number;
    endDate?: number;
    accountId?: string;
  }
): Promise<DatabaseResult<{period: string, income: number, expense: number, net: number}[]>> {
  const db = openDatabase();
  
  // Definir la expresión de agrupación según el parámetro groupBy
  let timeGroup: string;
  switch (groupBy) {
    case 'day':
      timeGroup = "strftime('%Y-%m-%d', datetime(date / 1000, 'unixepoch'))";
      break;
    case 'week':
      timeGroup = "strftime('%Y-%W', datetime(date / 1000, 'unixepoch'))";
      break;
    case 'month':
      timeGroup = "strftime('%Y-%m', datetime(date / 1000, 'unixepoch'))";
      break;
    default:
      return { success: false, error: "Parámetro de agrupación no válido" };
  }
  
  let query = `
    SELECT 
      ${timeGroup} as period,
      SUM(CASE WHEN type = 'income' THEN amount ELSE 0 END) as income,
      SUM(CASE WHEN type = 'expense' THEN amount ELSE 0 END) as expense,
      SUM(CASE WHEN type = 'income' THEN amount WHEN type = 'expense' THEN -amount ELSE 0 END) as net
    FROM transactions 
    WHERE is_deleted = 0 AND type != 'transfer'
  `;
  
  const queryParams: any[] = [];
  
  // Aplicamos los filtros si están presentes
  if (filters?.accountId) {
    query += ` AND account_id = ?`;
    queryParams.push(filters.accountId);
  }
  
  if (filters?.startDate) {
    query += ` AND date >= ?`;
    queryParams.push(filters.startDate);
  }
  
  if (filters?.endDate) {
    query += ` AND date <= ?`;
    queryParams.push(filters.endDate);
  }
  
  // Agrupamos y ordenamos
  query += ` GROUP BY period ORDER BY period`;
  
  return new Promise((resolve) => {
    db.withTransactionAsync(async () => {
      try {
        const cashFlow = await db.getAllAsync<{period: string, income: number, expense: number, net: number}>(
          query, 
          queryParams
        );
        resolve({ success: true, data: cashFlow });
      } catch (error) {
        resolve({ success: false, error: (error as Error).message });
      }
    });
  });
}

/**
 * Funciones de conveniencia para crear tipos específicos de transacciones
 */

/**
 * Crea una nueva transacción de ingreso
 */
export async function addIncome(
  accountId: string,
  amount: number,
  categoryId?: string,
  description?: string,
  date?: number
): Promise<DatabaseResult<Transaction>> {
  return createTransaction({
    account_id: accountId,
    amount,
    category_id: categoryId,
    description,
    date,
    type: 'income'
  });
}

/**
 * Crea una nueva transacción de gasto
 */
export async function addExpense(
  accountId: string,
  amount: number,
  categoryId?: string,
  description?: string,
  date?: number
): Promise<DatabaseResult<Transaction>> {
  return createTransaction({
    account_id: accountId,
    amount,
    category_id: categoryId,
    description,
    date,
    type: 'expense'
  });
}

/**
 * Crea una nueva transacción de transferencia entre cuentas
 */
export async function transferMoney(
  fromAccountId: string,
  toAccountId: string,
  amount: number,
  description?: string,
  date?: number
): Promise<DatabaseResult<Transaction>> {
  return createTransaction({
    account_id: fromAccountId,
    to_account_id: toAccountId,
    amount,
    description,
    date,
    type: 'transfer'
  });
}
